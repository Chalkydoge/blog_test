---
title: 下午茶 1010-1014
date: 2022-10-15 19:17:57
tags:
- 下午茶
---

<!-- more -->

# 下午茶合集

## 10.14-1407D


## 10.13-1286A

本质：`1-n`排列挖掉几个数字，求一种放法，使得相邻的数，奇偶性不同的数量最小。

考虑奇数&偶数可以放的数量, 以及看到**相邻**，立刻反应过来这是一个序列dp的问题

状态定义:

- `f[i][j][k][0/1]` 表示 `[0:i]`位置，取了`[j]`个奇数，`[k]`个偶数，末尾取值是`奇数1/偶数0`的最小操作数；最终答案就是`f[n][*][*][0/1]`的最小值

- 实际上可以优化成 `f[i][j][0/1]`,考虑到题目中写明了'是一个$1-n$的排列'，所以一定是有$n/2$个偶数，剩下都是奇数，因此可以去掉上面的一个维度；最终答案就是`f[n][n/2][0/1]`的最小值

- 更进一步，这里`f[i][j][0/1]`只和前一个状态`f[i-1][**][**]`有关系，所以实际上可以压缩这个维度

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int maxn = 0x3f3f3f3f;

int n;
int p[105];

// f[i][j][0/1]
// 前i个数, 填了j个偶数, 末尾是偶数/奇数的最小对数
int f[105][105][2];

// if: [i] = 0, could fill
// f[i][j][0] <- f[i - 1][j - 1][0] + 0, f[i - 1][j][1] + 1, 
// f[i][j][1] <- f[i - 1][j - 1][1] + 0, f[i - 1][j][0] + 1,

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> p[i];
    }
    memset(f, 0x3f, sizeof(f));
    f[0][0][0] = 0;
    f[0][0][1] = 0;
    for (int i = 1; i <= n; ++i) {
        // number of evens
        for (int j = 0; j <= n / 2; ++j) {
            // p[i] is even, or p[i] is 0 and filled even
            if (j > 0 && p[i] % 2 == 0) {
                f[i][j][0] = min(f[i - 1][j - 1][0], f[i - 1][j - 1][1] + 1);
            }
            if (p[i] == 0 || p[i] % 2 > 0) {
                f[i][j][1] = min(f[i - 1][j][0] + 1, f[i - 1][j][1]);
            }
        }
    }

    cout << min(f[n][n / 2][0], f[n][n / 2][1]) << '\n';
    return 0;
}
```

## 10.12-1651D

输入 $n(\lt 2e5)$ 和 $n$ 个二维平面上的互不相同的整点，坐标范围 $[1,2e5]$。
对每个整点，输出离它曼哈顿距离最近的，且不在输入中的整点。

两点的曼哈顿距离=横坐标之差的绝对值+纵坐标之差的绝对值。

1. 可能有些点，它的四周就是空的，那么对于这些点而言直接返回其中一个就行了

2. 内侧的点怎么找到最近? 从与它相邻的外部点转移过来就是最近了

3. 特别的BFS技巧，从外部点(可行解)向内(待求解)的方向进行BFS，保证内部点的解是最优的。

## 10.11-988F

## 10.10-38E

弹珠游戏
